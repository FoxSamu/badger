plugins {
    kotlin("jvm")
    kotlin("plugin.serialization")

    idea
    eclipse

    application
}

val project_name: String by properties
val project_group: String by properties
val project_version: String by properties

group = project_group
version = project_version

application {
    val main_class: String by properties
    mainClass = main_class
}

idea {
    module {
        isDownloadSources = true
    }
}

eclipse {
    classpath {
        isDownloadSources = true
    }
}

kotlin {
    jvmToolchain(17)
}

repositories {
    mavenCentral()
}

val buildInfoDirectory = layout.buildDirectory.file("buildInfo").get().asFile

sourceSets {
    main {
        kotlin.srcDir(buildInfoDirectory)
    }
}

fun skikoArch(): String {
    val osName: String = System.getProperty("os.name")
    val targetOs = when {
        osName == "Mac OS X" -> "macos"
        osName.startsWith("Win") -> "windows"
        osName.startsWith("Linux") -> "linux"
        else -> error("Unsupported OS: $osName")
    }

    val targetArch = when (val osArch: String = System.getProperty("os.arch")) {
        "x86_64", "amd64" -> "x64"
        "aarch64" -> "arm64"
        else -> error("Unsupported arch: $osArch")
    }

    return "$targetOs-$targetArch"
}

fun dep(name: String): Any? {
    return properties["version_$name"]
}

dependencies {
    // Parser
    implementation("org.antlr:antlr4:${dep("antlr")}")
    implementation(project(":parser"))

    // Skia
    implementation("org.jetbrains.skiko:skiko:${dep("skiko")}")
    runtimeOnly("org.jetbrains.skiko:skiko-awt-runtime-${skikoArch()}:${dep("skiko")}")

    // PDF
    implementation("com.github.librepdf:openpdf:${dep("openpdf")}")

    // Ktor
    implementation("io.ktor:ktor-server-core:${dep("ktor")}")
    implementation("io.ktor:ktor-server-cio:${dep("ktor")}")
    implementation("io.ktor:ktor-client-core:${dep("ktor")}")
    implementation("io.ktor:ktor-client-cio:${dep("ktor")}")

    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:${dep("coroutines")}")

    // Serialisation
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:${dep("serialization")}")

    // Logging
    implementation("org.apache.logging.log4j:log4j-core:${dep("log4j")}")
    implementation("org.apache.logging.log4j:log4j-api:${dep("log4j")}")
    implementation("org.apache.logging.log4j:log4j-slf4j2-impl:${dep("log4j")}")

    // Kaml
    implementation("com.charleskorn.kaml:kaml:${dep("kaml")}")

    // MinIO
    implementation("io.minio:minio:${dep("minio")}") {
        exclude(group = "org.apache.commons", module = "commons-compress")
    }
    // MinIO uses a vulnerable version of commons-compress,
    // they fixed it recently by updating to commons-compress
    // 1.28.0 but this has not yet been released. Let's manually
    // replace it.
    implementation("org.apache.commons:commons-compress:${dep("commons_compress")}")

    // Testing
    testImplementation(kotlin("test"))
}

val writeBuildInfo = tasks.create("writeBuildInfo") {
    inputs.property("version", project_version)
    inputs.property("name", project_name)
    inputs.property("group", project_group)

    outputs.dir(buildInfoDirectory)

    doLast {
        val buildInfoFile = file("$buildInfoDirectory/net/foxboi/badger/BuildInfo.kt")
        buildInfoFile.parentFile.mkdirs()
        buildInfoFile.writeText(
            """
            package net.foxboi.badger
            
            /**
             * Build information generated by Gradle.
             */
            data object BuildInfo {
                const val VERSION = "$project_version"
                const val NAME = "$project_name"
                const val GROUP = "$project_group"
            }
        """.trimIndent()
        )
    }
}

tasks.test.configure {
    useJUnitPlatform()
}

tasks.run.configure {
    workingDir = file("$projectDir")
    environment("CONFIG_PATH" to "./example_config.yml")
}

tasks.compileKotlin.configure {
    dependsOn(writeBuildInfo)
}